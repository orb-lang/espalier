digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 365"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-5"]


section_1 -> { header_2 prose_3 section_4}
{rank=same; header_2 prose_3 section_4}

header_2 [label="1 : Grammar Module"]

prose_3 [label="prose"]

section_4 [label="section: 6-118"]


header_2 -> leaf_5
leaf_5  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grammar Module"]
prose_3 -> { raw_6}
{rank=same; raw_6}

raw_6 [label="raw"]


raw_6 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The grammar module returns one function, which generates
a grammar. 
"]
section_4 -> { header_8 prose_9 prose_10 prose_11 section_12 section_13 section_14 section_15}
{rank=same; header_8 prose_9 prose_10 prose_11 section_12 section_13 section_14 section_15}

header_8 [label="2 : Parameters"]

prose_9 [label="prose"]

prose_10 [label="prose"]

prose_11 [label="prose"]

section_12 [label="section: 16-45"]

section_13 [label="section: 46-69"]

section_14 [label="section: 70-118"]

section_15 [label="section: 119-159"]


header_8 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Parameters"]
prose_9 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This function takes two parameters, namely:
"]
prose_10 -> { raw_19 prespace_20 literal_21 raw_22}
{rank=same; raw_19 prespace_20 literal_21 raw_22}

raw_19 [label="raw"]

prespace_20 [label="prespace"]

literal_21 [label="literal"]

raw_22 [label="raw"]


raw_19 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - grammar_template :  A function with one parameter, which must be"]
prespace_20 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_21 -> leaf_25
leaf_25  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_ENV"]
raw_22 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
  - metas :  A map with keys of string and values of Node subclass constructors.
"]
prose_11 -> { raw_27}
{rank=same; raw_27}

raw_27 [label="raw"]


raw_27 -> leaf_28
leaf_28  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Both of these are reasonably complex.

"]
section_12 -> { header_29 prose_30 prose_31 prose_32 prose_33 prose_34 prose_35 prose_36}
{rank=same; header_29 prose_30 prose_31 prose_32 prose_33 prose_34 prose_35 prose_36}

header_29 [label="3 : grammar_template"]

prose_30 [label="prose"]

prose_31 [label="prose"]

prose_32 [label="prose"]

prose_33 [label="prose"]

prose_34 [label="prose"]

prose_35 [label="prose"]

prose_36 [label="prose"]


header_29 -> leaf_37
leaf_37  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** grammar_template"]
prose_30 -> { raw_38 prespace_39 literal_40 raw_41}
{rank=same; raw_38 prespace_39 literal_40 raw_41}

raw_38 [label="raw"]

prespace_39 [label="prespace"]

literal_40 [label="literal"]

raw_41 [label="raw"]


raw_38 -> leaf_42
leaf_42  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The internal function @define creates a custom environment variable, neatly
sidestepping lua's pedantic insistance on prepending"]
prespace_39 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_40 -> leaf_44
leaf_44  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local"]
raw_41 -> leaf_45
leaf_45  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to all values of 
significance. 
"]
prose_31 -> { raw_46}
{rank=same; raw_46}

raw_46 [label="raw"]


raw_46 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More relevantly, it constructs a full grammar, which will return a table of
type Node. 
"]
prose_32 -> { raw_48 prespace_49 literal_50 raw_51}
{rank=same; raw_48 prespace_49 literal_50 raw_51}

raw_48 [label="raw"]

prespace_49 [label="prespace"]

literal_50 [label="literal"]

raw_51 [label="raw"]


raw_48 -> leaf_52
leaf_52  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you stick to"]
prespace_49 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_50 -> leaf_54
leaf_54  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
raw_51 -> leaf_55
leaf_55  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" patterns, as you should, all array values will be of
Node, as is intended.  Captures will interpolate various other sorts of Lua
values, which will induce halting in some places and silently corrupt
execution in others. 
"]
prose_33 -> { raw_56 link_57 raw_58}
{rank=same; raw_56 link_57 raw_58}

raw_56 [label="raw"]

link_57 [label="link"]

raw_58 [label="raw"]


raw_56 -> leaf_59
leaf_59  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Though as yet poorly thought through, the "]
link_57 -> { anchortext_60 url_61}
{rank=same; anchortext_60 url_61}

anchortext_60 [label="anchortext"]

url_61 [label="url"]


anchortext_60 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt module"]
url_61 -> leaf_63
leaf_63  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./elpatt"]
raw_58 -> leaf_64
leaf_64  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is
intended to provide only those patterns which are allowed in Grammars, while
expanding the scope of some favorites to properly respect utf-8 and otherwise
behave. 
"]
prose_34 -> { raw_65 link_66 raw_67}
{rank=same; raw_65 link_66 raw_67}

raw_65 [label="raw"]

link_66 [label="link"]

raw_67 [label="raw"]


raw_65 -> leaf_68
leaf_68  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are examples of the format in the "]
link_66 -> { anchortext_69 url_70}
{rank=same; anchortext_69 url_70}

anchortext_69 [label="anchortext"]

url_70 [label="url"]


anchortext_69 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spec module"]
url_70 -> leaf_72
leaf_72  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./spec"]
raw_67 -> leaf_73
leaf_73  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
prose_35 -> { raw_74}
{rank=same; raw_74}

raw_74 [label="raw"]


raw_74 -> leaf_75
leaf_75  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Special fields include:
"]
prose_36 -> { raw_76}
{rank=same; raw_76}

raw_76 [label="raw"]


raw_76 -> leaf_77
leaf_77  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  START :  a string which must be the same as the starting rule.
  -  SUPPRESS :  either a string or an array of strings. These rules will be
                 removed from the Node. 
  -  P :  The lpeg P function.  Recognizes a certain pattern.
  -  V :  The lpeg V function.  Used for non-terminal rvalues in a grammar. 

"]
section_13 -> { header_78 prose_79 prose_80 prose_81 prose_82 prose_83}
{rank=same; header_78 prose_79 prose_80 prose_81 prose_82 prose_83}

header_78 [label="3 : metas"]

prose_79 [label="prose"]

prose_80 [label="prose"]

prose_81 [label="prose"]

prose_82 [label="prose"]

prose_83 [label="prose"]


header_78 -> leaf_84
leaf_84  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** metas"]
prose_79 -> { raw_85}
{rank=same; raw_85}

raw_85 [label="raw"]


raw_85 -> leaf_86
leaf_86  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  By default a node will inherit from the Node class.  If you want custom behavior,
you must pass in a table of metatable constructors.
"]
prose_80 -> { raw_87 prespace_88 literal_89 raw_90 prespace_91 literal_92 raw_93 prespace_94 literal_95 raw_96 prespace_97 literal_98 raw_99 prespace_100 literal_101 raw_102 prespace_103 literal_104 raw_105}
{rank=same; raw_87 prespace_88 literal_89 raw_90 prespace_91 literal_92 raw_93 prespace_94 literal_95 raw_96 prespace_97 literal_98 raw_99 prespace_100 literal_101 raw_102 prespace_103 literal_104 raw_105}

raw_87 [label="raw"]

prespace_88 [label="prespace"]

literal_89 [label="literal"]

raw_90 [label="raw"]

prespace_91 [label="prespace"]

literal_92 [label="literal"]

raw_93 [label="raw"]

prespace_94 [label="prespace"]

literal_95 [label="literal"]

raw_96 [label="raw"]

prespace_97 [label="prespace"]

literal_98 [label="literal"]

raw_99 [label="raw"]

prespace_100 [label="prespace"]

literal_101 [label="literal"]

raw_102 [label="raw"]

prespace_103 [label="prespace"]

literal_104 [label="literal"]

raw_105 [label="raw"]


raw_87 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That's a fairly specific beast.  Any rule defined above will have an"]
prespace_88 -> leaf_107
leaf_107  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_89 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_90 -> leaf_109
leaf_109  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
corresonding to the name of the rule.  Unless"]
prespace_91 -> leaf_110
leaf_110  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_92 -> leaf_111
leaf_111  [color=Gray,shape=rectangle,fontname=Inconsolata,label="SUPPRESS"]
raw_93 -> leaf_112
leaf_112  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ed, this will become
a Node.  If the"]
prespace_94 -> leaf_113
leaf_113  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_95 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="metas"]
raw_96 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter has a key corresponding to"]
prespace_97 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_98 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_99 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", then it
must return a function taking two parameters:
   
   - node :  The node under construction, which under normal circumstances will
             already have the"]
prespace_100 -> leaf_119
leaf_119  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_101 -> leaf_120
leaf_120  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_102 -> leaf_121
leaf_121  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and"]
prespace_103 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_104 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_105 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" fields.
   - str  :  The entire str the grammar is parsing.
"]
prose_81 -> { raw_125}
{rank=same; raw_125}

raw_125 [label="raw"]


raw_125 -> leaf_126
leaf_126  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which must return that same node, decorated in whatever fashion is appropriate.
"]
prose_82 -> { raw_127 prespace_128 literal_129 raw_130 prespace_131 literal_132 raw_133}
{rank=same; raw_127 prespace_128 literal_129 raw_130 prespace_131 literal_132 raw_133}

raw_127 [label="raw"]

prespace_128 [label="prespace"]

literal_129 [label="literal"]

raw_130 [label="raw"]

prespace_131 [label="prespace"]

literal_132 [label="literal"]

raw_133 [label="raw"]


raw_127 -> leaf_134
leaf_134  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The node will not have a metatable at this point, and the function must attach a
metatable with"]
prespace_128 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_129 -> leaf_136
leaf_136  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
raw_130 -> leaf_137
leaf_137  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" equal to some table which itself has the"]
prespace_131 -> leaf_138
leaf_138  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_132 -> leaf_139
leaf_139  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
raw_133 -> leaf_140
leaf_140  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Node as some recursive backstop.
"]
prose_83 -> { raw_141 prespace_142 italic_143 raw_144}
{rank=same; raw_141 prespace_142 italic_143 raw_144}

raw_141 [label="raw"]

prespace_142 [label="prespace"]

italic_143 [label="italic"]

raw_144 [label="raw"]


raw_141 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You might say the return value must"]
prespace_142 -> leaf_146
leaf_146  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
italic_143 -> leaf_147
leaf_147  [color=Gray,shape=rectangle,fontname=Inconsolata,label="inherit"]
raw_144 -> leaf_148
leaf_148  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" from Node, if we were using
a language that did that sort of thing. 

"]
section_14 -> { header_149 prose_150 prose_151 prose_152 codeblock_153 prose_154 prose_155 codeblock_156}
{rank=same; header_149 prose_150 prose_151 prose_152 codeblock_153 prose_154 prose_155 codeblock_156}

header_149 [label="3 : includes"]

prose_150 [label="prose"]

prose_151 [label="prose"]

prose_152 [label="prose"]

codeblock_153 [label="code block 82-95"]

prose_154 [label="prose"]

prose_155 [label="prose"]

codeblock_156 [label="code block 101-116"]


header_149 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_150 -> { raw_158}
{rank=same; raw_158}

raw_158 [label="raw"]


raw_158 -> leaf_159
leaf_159  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


- [ ] #todo  Note the require strings below, which prevent this from
             being a usable library. 
"]
prose_151 -> { raw_160 prespace_161 literal_162 raw_163 prespace_164 literal_165 raw_166}
{rank=same; raw_160 prespace_161 literal_162 raw_163 prespace_164 literal_165 raw_166}

raw_160 [label="raw"]

prespace_161 [label="prespace"]

literal_162 [label="literal"]

raw_163 [label="raw"]

prespace_164 [label="prespace"]

literal_165 [label="literal"]

raw_166 [label="raw"]


raw_160 -> leaf_167
leaf_167  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             The problem is almost a philosophical one, and it's what I'm
             setting out to solve with"]
prespace_161 -> leaf_168
leaf_168  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_162 -> leaf_169
leaf_169  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
raw_163 -> leaf_170
leaf_170  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and"]
prespace_164 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_165 -> leaf_172
leaf_172  [color=Gray,shape=rectangle,fontname=Inconsolata,label="manifest"]
raw_166 -> leaf_173
leaf_173  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_152 -> { raw_174 prespace_175 literal_176 raw_177}
{rank=same; raw_174 prespace_175 literal_176 raw_177}

raw_174 [label="raw"]

prespace_175 [label="prespace"]

literal_176 [label="literal"]

raw_177 [label="raw"]


raw_174 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             In the meantime,"]
prespace_175 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_176 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpegnode"]
raw_177 -> leaf_181
leaf_181  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" has one consumer. Let's keep it
             happy. 
"]
codeblock_153 -> leaf_182
leaf_182  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"status\" ()
s.verbose = false
s.angry   = false

local a = require \"ansi\"

local Node = require \"node/node\"
local elpatt = require \"node/elpatt\"

local DROP = elpatt.DROP"]
prose_154 -> { raw_183}
{rank=same; raw_183}

raw_183 [label="raw"]


raw_183 -> leaf_184
leaf_184  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I like the dedication shown in this style of import.
"]
prose_155 -> { raw_185}
{rank=same; raw_185}

raw_185 [label="raw"]


raw_185 -> leaf_186
leaf_186  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's the kind of thing I'd like to automate. 
"]
codeblock_156 -> leaf_187
leaf_187  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local assert = assert
local string, io = assert( string ), assert( io )
local V = string.sub( assert( _VERSION ), -4 )
local _G = assert( _G )
local error = assert( error )
local pairs = assert( pairs )
local next = assert( next )
local type = assert( type )
local tostring = assert( tostring )
local setmetatable = assert( setmetatable )
if V == \" 5.1\" then
   local setfenv = assert( setfenv )
   local getfenv = assert( getfenv )
end"]
section_15 -> { header_188 prose_189 codeblock_190 section_191 section_192}
{rank=same; header_188 prose_189 codeblock_190 section_191 section_192}

header_188 [label="3 : make_ast_node"]

prose_189 [label="prose"]

codeblock_190 [label="code block 124-126"]

section_191 [label="section: 129-159"]

section_192 [label="section: 160-365"]


header_188 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** make_ast_node"]
prose_189 -> { raw_194}
{rank=same; raw_194}

raw_194 [label="raw"]


raw_194 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This takes a lot of parameters and does a lot of things. 

"]
codeblock_190 -> leaf_196
leaf_196  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function make_ast_node(id, first, t, last, str, metas, offset)"]
section_191 -> { header_197 prose_198 prose_199 codeblock_200}
{rank=same; header_197 prose_198 prose_199 codeblock_200}

header_197 [label="4 : setup values and metatables"]

prose_198 [label="prose"]

prose_199 [label="prose"]

codeblock_200 [label="code block 139-157"]


header_197 -> leaf_201
leaf_201  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup values and metatables"]
prose_198 -> { raw_202 link_203 raw_204}
{rank=same; raw_202 link_203 raw_204}

raw_202 [label="raw"]

link_203 [label="link"]

raw_204 [label="raw"]


raw_202 -> leaf_205
leaf_205  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  As "]
link_203 -> { anchortext_206 url_207}
{rank=same; anchortext_206 url_207}

anchortext_206 [label="anchortext"]

url_207 [label="url"]


anchortext_206 -> leaf_208
leaf_208  [color=Gray,shape=rectangle,fontname=Inconsolata,label="covered elsewhere"]
url_207 -> leaf_209
leaf_209  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_204 -> leaf_210
leaf_210  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", we accept three varieties of
metatable verb.  An ordinary table is assigned; a table with __call is 
called, as is an ordinary function.
"]
prose_199 -> { raw_211 prespace_212 literal_213 raw_214 prespace_215 literal_216 raw_217 prespace_218 literal_219 raw_220}
{rank=same; raw_211 prespace_212 literal_213 raw_214 prespace_215 literal_216 raw_217 prespace_218 literal_219 raw_220}

raw_211 [label="raw"]

prespace_212 [label="prespace"]

literal_213 [label="literal"]

raw_214 [label="raw"]

prespace_215 [label="prespace"]

literal_216 [label="literal"]

raw_217 [label="raw"]

prespace_218 [label="prespace"]

literal_219 [label="literal"]

raw_220 [label="raw"]


raw_211 -> leaf_221
leaf_221  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The latter two are expected to return the original table, now a descendent
of"]
prespace_212 -> leaf_222
leaf_222  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_213 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node"]
raw_214 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  This need not have an"]
prespace_215 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_216 -> leaf_226
leaf_226  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_217 -> leaf_227
leaf_227  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field which is the same as the"]
prespace_218 -> leaf_228
leaf_228  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_219 -> leaf_229
leaf_229  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_220 -> leaf_230
leaf_230  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
parameter.
"]
codeblock_200 -> leaf_231
leaf_231  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   local offset = offset or 0
   t.first = first + offset
   t.last  = last + offset - 1
   t.str   = str
   if metas[id] then
      local meta = metas[id]
      if type(meta) == \"function\" or meta.__call then
        t = metas[id](t, str)
      else
        t = setmetatable(t, meta)
      end
      assert(t.id)
   else
      t.id = id
       setmetatable(t, {__index = Node,
                     __tostring = Node.toString})
   end"]
section_192 -> { header_232 prose_233 prose_234 prose_235 prose_236 prose_237 prose_238 prose_239 prose_240 prose_241 prose_242 prose_243 prose_244 codeblock_245 codeblock_246 codeblock_247 codeblock_248}
{rank=same; header_232 prose_233 prose_234 prose_235 prose_236 prose_237 prose_238 prose_239 prose_240 prose_241 prose_242 prose_243 prose_244 codeblock_245 codeblock_246 codeblock_247 codeblock_248}

header_232 [label="4 : DROP"]

prose_233 [label="prose"]

prose_234 [label="prose"]

prose_235 [label="prose"]

prose_236 [label="prose"]

prose_237 [label="prose"]

prose_238 [label="prose"]

prose_239 [label="prose"]

prose_240 [label="prose"]

prose_241 [label="prose"]

prose_242 [label="prose"]

prose_243 [label="prose"]

prose_244 [label="prose"]

codeblock_245 [label="code block 204-320"]

codeblock_246 [label="code block 322-341"]

codeblock_247 [label="code block 344-361"]

codeblock_248 [label="code block 363-365"]


header_232 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" DROP

  T"]
prose_233 -> { raw_250 prespace_251 literal_252 raw_253}
{rank=same; raw_250 prespace_251 literal_252 raw_253}

raw_250 [label="raw"]

prespace_251 [label="prespace"]

literal_252 [label="literal"]

raw_253 [label="raw"]


raw_250 -> leaf_254
leaf_254  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The rule"]
prespace_251 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_252 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt.D"]
raw_253 -> leaf_257
leaf_257  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" causes the match to be dropped. In order for
this to give use the results we want, we must adjust the peer and
parent nodes while removing the captured element from the table. 
"]
prose_234 -> { raw_258 prespace_259 literal_260 raw_261}
{rank=same; raw_258 prespace_259 literal_260 raw_261}

raw_258 [label="raw"]

prespace_259 [label="prespace"]

literal_260 [label="literal"]

raw_261 [label="raw"]


raw_258 -> leaf_262
leaf_262  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The use case is for eloquently expressed 'wrapper' patterns, which occur
frequently in real languages. In a"]
prespace_259 -> leaf_263
leaf_263  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_260 -> leaf_264
leaf_264  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(typical lisp expression)"]
raw_261 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" we don't need
the parentheses and would like our span not to include them.
"]
prose_235 -> { raw_266 prespace_267 literal_268 raw_269 prespace_270 literal_271 raw_272 prespace_273 literal_274 raw_275}
{rank=same; raw_266 prespace_267 literal_268 raw_269 prespace_270 literal_271 raw_272 prespace_273 literal_274 raw_275}

raw_266 [label="raw"]

prespace_267 [label="prespace"]

literal_268 [label="literal"]

raw_269 [label="raw"]

prespace_270 [label="prespace"]

literal_271 [label="literal"]

raw_272 [label="raw"]

prespace_273 [label="prespace"]

literal_274 [label="literal"]

raw_275 [label="raw"]


raw_266 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We could use a pattern like"]
prespace_267 -> leaf_277
leaf_277  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_268 -> leaf_278
leaf_278  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"formwrap\""]
raw_269 -> leaf_279
leaf_279  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and then SUPPRESS"]
prespace_270 -> leaf_280
leaf_280  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_271 -> leaf_281
leaf_281  [color=Gray,shape=rectangle,fontname=Inconsolata,label="formwrap"]
raw_272 -> leaf_282
leaf_282  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", but
this is less eloquent than"]
prespace_273 -> leaf_283
leaf_283  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_274 -> leaf_284
leaf_284  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(P\"(\") * V\"form\" *  D(P\")\")"]
raw_275 -> leaf_285
leaf_285  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_236 -> { raw_286 prespace_287 bold_288 raw_289}
{rank=same; raw_286 prespace_287 bold_288 raw_289}

raw_286 [label="raw"]

prespace_287 [label="prespace"]

bold_288 [label="bold"]

raw_289 [label="raw"]


raw_286 -> leaf_290
leaf_290  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which is admittedly hard to look at.  We prefer the form
=D(pal)"]
prespace_287 -> leaf_291
leaf_291  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
bold_288 -> leaf_292
leaf_292  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" V\"form\" "]
raw_289 -> leaf_293
leaf_293  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" D(par)= for this reason among others.
"]
prose_237 -> { raw_294 prespace_295 literal_296 raw_297}
{rank=same; raw_294 prespace_295 literal_296 raw_297}

raw_294 [label="raw"]

prespace_295 [label="prespace"]

literal_296 [label="literal"]

raw_297 [label="raw"]


raw_294 -> leaf_298
leaf_298  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The algorithm moves from the right to the left, because"]
prespace_295 -> leaf_299
leaf_299  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_296 -> leaf_300
leaf_300  [color=Gray,shape=rectangle,fontname=Inconsolata,label="table.remove(t)"]
raw_297 -> leaf_301
leaf_301  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
is O(1) so we can strip any amount of rightward droppage first.  It is
correspondingly more expensive to strip middle drops, and most expensive
to strip leftmost drops.
"]
prose_238 -> { raw_302 prespace_303 literal_304 raw_305}
{rank=same; raw_302 prespace_303 literal_304 raw_305}

raw_302 [label="raw"]

prespace_303 [label="prespace"]

literal_304 [label="literal"]

raw_305 [label="raw"]


raw_302 -> leaf_306
leaf_306  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More importantly, if we counted up, we'd be tracking"]
prespace_303 -> leaf_307
leaf_307  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_304 -> leaf_308
leaf_308  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#t"]
raw_305 -> leaf_309
leaf_309  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", a moving target.
Counting to 1 neatly prevents this.
"]
prose_239 -> { raw_310}
{rank=same; raw_310}

raw_310 [label="raw"]


raw_310 -> leaf_311
leaf_311  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   -  [ ] #Todo :Faster:
"]
prose_240 -> { raw_312}
{rank=same; raw_312}

raw_312 [label="raw"]


raw_312 -> leaf_313
leaf_313  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  This algorithm, as we discussed, goes quadratic toward the left side.
        The correct way to go is if we see any drop, flip a dirty bit, and 
        compact upward.
"]
prose_241 -> { raw_314 prespace_315 literal_316 raw_317}
{rank=same; raw_314 prespace_315 literal_316 raw_317}

raw_314 [label="raw"]

prespace_315 [label="prespace"]

literal_316 [label="literal"]

raw_317 [label="raw"]


raw_314 -> leaf_318
leaf_318  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  More to the point, the mere inclusion of this much"]
prespace_315 -> leaf_319
leaf_319  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" "]
literal_316 -> leaf_320
leaf_320  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s:"]
raw_317 -> leaf_321
leaf_321  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" slows the 
        algorithm to an utter crawl. The concatenations happen anyway, to
        pass the string into the status module.
"]
prose_242 -> { raw_322}
{rank=same; raw_322}

raw_322 [label="raw"]


raw_322 -> leaf_323
leaf_323  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        This is probably 10x the cost in real work.
"]
prose_243 -> { raw_324}
{rank=same; raw_324}

raw_324 [label="raw"]


raw_324 -> leaf_325
leaf_325  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        Why am I doing it in such a dumb way? This is a literate programming
        environment, and I'm building a language with templates and macros
        and other useful access to state at compile time.
"]
prose_244 -> { raw_326}
{rank=same; raw_326}

raw_326 [label="raw"]


raw_326 -> leaf_327
leaf_327  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        That's two ways to remove the verbosity and other printfs when they
        aren't wanted.  Better to simulate the correct behavior until I can
        provide it. 
"]
codeblock_245 -> leaf_328
leaf_328  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   for i = #t, 1, -1 do 
      local cap = t[i] 
      if type(cap) ~= \"table\" then
         s:complain(\"CAPTURE ISSUE\", 
                    \"type of capture subgroup is \" .. type(v) .. \"\\n\")
      end
      if cap.DROP and getmetatable(cap) == DROP then
         s:verb(\"drops in \" .. a.bright(t.id))
         if i == #t then
            s:verb(a.red(\"rightmost\") .. \" remaining node\")
            s:verb(\"  t.$: \" .. tostring(t.last) .. \" Î”: \"
                   .. tostring(cap.last - cap.first))
            t.last = t.last - (cap.last - cap.first)
            table.remove(t)
            s:verb(\"  new t.$: \" .. tostring(t.last))
         else
            -- Here we may be either in the middle or at the leftmost
            -- margin.  Leftmost means either we're at index 1, or that
            -- all children to the left, down to 1, are all DROPs. 
            local leftmost = (i == 1)
            if leftmost then
               s:verb(a.cyan(\"  leftmost\") .. \" remaining node\")
               s:verb(\"    t.^: \" .. tostring(t.first)
                      .. \" D.$: \" .. tostring(cap.last))
               t.first = cap.last
               s:verb(\"    new t.^: \" .. tostring(t.first))
               table.remove(t, 1)
            else
               leftmost = true -- provisionally since cap.DROP
               for j = i, 1, -1 do
                 leftmost = leftmost and t[j].DROP 
                                     and getmetatable(t[j]) == DROP
                 if not leftmost then break end
               end
               if leftmost then
                  s:verb(a.cyan(\"  leftmost inner\") .. \" remaining node\")
                  s:verb(\"    t.^: \" .. tostring(t.first)
                         .. \" D.$: \" .. tostring(cap.last))
                  t.first = cap.last
                  s:verb(\"    new t.^: \" .. tostring(t.first))
                  for j = i, 1, -1 do
                     -- this is quadradic but correct 
                     -- and easy to understand.
                     table.remove(t, j)
                     break
                  end
               else
                  s:verb(a.green(\"  middle\") .. \" node dropped\")
                  table.remove(t, i)
               end
            end
         end
      end 
   end
   assert(t.isNode, \"failed isNode: \" .. id)
   assert(t.str)
   return t
end


-- some useful/common lpeg patterns
local Cp = L.Cp
local Cc = L.Cc
local Ct = L.Ct
local arg1_str = L.Carg(1)
local arg2_metas = L.Carg(2)
local arg3_offset = L.Carg(3)


-- setup an environment where you can easily define lpeg grammars
-- with lots of syntax sugar
local function define(func, g, e)
  g = g or {}
  if e == nil then
    e = V == \" 5.1\" and getfenv(func) or _G
  end
  local suppressed = {}
  local env = {}
  local env_index = {
    START = function(name) g[1] = name end,
    SUPPRESS = function(...)
      suppressed = {}
      for i = 1, select('#', ...) do
        suppressed[select(i, ... )] = true
      end
    end,
    V = L.V,
    P = L.P,
  }

  setmetatable(env_index, { __index = e })
  setmetatable(env, {
    __index = env_index,
    __newindex = function( _, name, val )
      if suppressed[ name ] then
        g[ name ] = val
      else
        g[ name ] = (Cc(name) 
              * Cp() 
              * Ct(val)
              * Cp()
              * arg1_str
              * arg2_metas)
              * arg3_offset / make_ast_node
      end
    end
  })
  -- call passed function with custom environment (5.1- and 5.2-style)
  if V == \" 5.1\" then
    setfenv( func, env )
  end
  func( env )
  assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )
  return g
end"]
codeblock_246 -> leaf_329
leaf_329  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function refineMetas(metas)
  s:verb(\"refining metatables\")
  for id, meta in pairs(metas) do
    s:verb(\"  id: \" .. id .. \" type: \" .. type(meta))
    if type(meta) == \"table\" then
      if not meta[\"__tostring\"] then
        meta[\"__tostring\"] = Node.toString
      end
      if not meta.id then
        s:verb(\"    inserting metatable id: \" .. id)
        meta.id = id
      else
        s:verb(\"    id of \" .. id .. \" is \" .. meta.id)
      end
    end
  end
  return metas
end"]
codeblock_247 -> leaf_330
leaf_330  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(grammar_template, metas)
  if type(grammar_template) == 'function' then
    local metas = metas or {}
    metas = refineMetas(metas)
    local grammar = define(grammar_template, nil, metas)

    local function parse(str, offset)
      local offset = offset or 0
      return L.match(grammar, str, 1, str, metas, offset)
    end

    return parse
  else
    s:halt(\"no way to build grammar out of \" .. type(template))
  end
end"]
codeblock_248 -> leaf_331
leaf_331  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]

}
