digraph hierarchy {

node [fontname=Helvetica]
edge [style=dashed]

doc_0 [label="doc - 365"]


doc_0 -> { section_1}
{rank=same; section_1}

section_1 [label="section: 1-5"]


section_1 -> { header_2 prose_3 section_4}
{rank=same; header_2 prose_3 section_4}

header_2 [label="1 : Grammar Module"]

prose_3 [label="prose"]

section_4 [label="section: 6-118"]


header_2 -> leaf_5
leaf_5  [color=Gray,shape=rectangle,fontname=Inconsolata,label="* Grammar Module"]
prose_3 -> { raw_6}
{rank=same; raw_6}

raw_6 [label="raw"]


raw_6 -> leaf_7
leaf_7  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The grammar module returns one function, which generates
a grammar. 
"]
section_4 -> { header_8 prose_9 prose_10 prose_11 section_12 section_13 section_14 section_15}
{rank=same; header_8 prose_9 prose_10 prose_11 section_12 section_13 section_14 section_15}

header_8 [label="2 : Parameters"]

prose_9 [label="prose"]

prose_10 [label="prose"]

prose_11 [label="prose"]

section_12 [label="section: 16-45"]

section_13 [label="section: 46-69"]

section_14 [label="section: 70-118"]

section_15 [label="section: 119-159"]


header_8 -> leaf_16
leaf_16  [color=Gray,shape=rectangle,fontname=Inconsolata,label="** Parameters"]
prose_9 -> { raw_17}
{rank=same; raw_17}

raw_17 [label="raw"]


raw_17 -> leaf_18
leaf_18  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

This function takes two parameters, namely:
"]
prose_10 -> { raw_19 literal_20 raw_21}
{rank=same; raw_19 literal_20 raw_21}

raw_19 [label="raw"]

literal_20 [label="literal"]

raw_21 [label="raw"]


raw_19 -> leaf_22
leaf_22  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  - grammar_template :  A function with one parameter, which must be "]
literal_20 -> leaf_23
leaf_23  [color=Gray,shape=rectangle,fontname=Inconsolata,label="_ENV"]
raw_21 -> leaf_24
leaf_24  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
  - metas :  A map with keys of string and values of Node subclass constructors.
"]
prose_11 -> { raw_25}
{rank=same; raw_25}

raw_25 [label="raw"]


raw_25 -> leaf_26
leaf_26  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Both of these are reasonably complex.

"]
section_12 -> { header_27 prose_28 prose_29 prose_30 prose_31 prose_32 prose_33 prose_34}
{rank=same; header_27 prose_28 prose_29 prose_30 prose_31 prose_32 prose_33 prose_34}

header_27 [label="3 : grammar_template"]

prose_28 [label="prose"]

prose_29 [label="prose"]

prose_30 [label="prose"]

prose_31 [label="prose"]

prose_32 [label="prose"]

prose_33 [label="prose"]

prose_34 [label="prose"]


header_27 -> leaf_35
leaf_35  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** grammar_template"]
prose_28 -> { raw_36 literal_37 raw_38}
{rank=same; raw_36 literal_37 raw_38}

raw_36 [label="raw"]

literal_37 [label="literal"]

raw_38 [label="raw"]


raw_36 -> leaf_39
leaf_39  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The internal function @define creates a custom environment variable, neatly
sidestepping lua's pedantic insistance on prepending "]
literal_37 -> leaf_40
leaf_40  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local"]
raw_38 -> leaf_41
leaf_41  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" to all values of 
significance. 
"]
prose_29 -> { raw_42}
{rank=same; raw_42}

raw_42 [label="raw"]


raw_42 -> leaf_43
leaf_43  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More relevantly, it constructs a full grammar, which will return a table of
type Node. 
"]
prose_30 -> { raw_44 literal_45 raw_46}
{rank=same; raw_44 literal_45 raw_46}

raw_44 [label="raw"]

literal_45 [label="literal"]

raw_46 [label="raw"]


raw_44 -> leaf_47
leaf_47  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
If you stick to "]
literal_45 -> leaf_48
leaf_48  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpeg"]
raw_46 -> leaf_49
leaf_49  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" patterns, as you should, all array values will be of
Node, as is intended.  Captures will interpolate various other sorts of Lua
values, which will induce halting in some places and silently corrupt
execution in others. 
"]
prose_31 -> { raw_50 link_51 raw_52}
{rank=same; raw_50 link_51 raw_52}

raw_50 [label="raw"]

link_51 [label="link"]

raw_52 [label="raw"]


raw_50 -> leaf_53
leaf_53  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Though as yet poorly thought through, the "]
link_51 -> { anchortext_54 url_55}
{rank=same; anchortext_54 url_55}

anchortext_54 [label="anchortext"]

url_55 [label="url"]


anchortext_54 -> leaf_56
leaf_56  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt module"]
url_55 -> leaf_57
leaf_57  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./elpatt"]
raw_52 -> leaf_58
leaf_58  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" is
intended to provide only those patterns which are allowed in Grammars, while
expanding the scope of some favorites to properly respect utf-8 and otherwise
behave. 
"]
prose_32 -> { raw_59 link_60 raw_61}
{rank=same; raw_59 link_60 raw_61}

raw_59 [label="raw"]

link_60 [label="link"]

raw_61 [label="raw"]


raw_59 -> leaf_62
leaf_62  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
There are examples of the format in the "]
link_60 -> { anchortext_63 url_64}
{rank=same; anchortext_63 url_64}

anchortext_63 [label="anchortext"]

url_64 [label="url"]


anchortext_63 -> leaf_65
leaf_65  [color=Gray,shape=rectangle,fontname=Inconsolata,label="spec module"]
url_64 -> leaf_66
leaf_66  [color=Gray,shape=rectangle,fontname=Inconsolata,label="./spec"]
raw_61 -> leaf_67
leaf_67  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".
"]
prose_33 -> { raw_68}
{rank=same; raw_68}

raw_68 [label="raw"]


raw_68 -> leaf_69
leaf_69  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Special fields include:
"]
prose_34 -> { raw_70}
{rank=same; raw_70}

raw_70 [label="raw"]


raw_70 -> leaf_71
leaf_71  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
  -  START :  a string which must be the same as the starting rule.
  -  SUPPRESS :  either a string or an array of strings. These rules will be
                 removed from the Node. 
  -  P :  The lpeg P function.  Recognizes a certain pattern.
  -  V :  The lpeg V function.  Used for non-terminal rvalues in a grammar. 

"]
section_13 -> { header_72 prose_73 prose_74 prose_75 prose_76 prose_77}
{rank=same; header_72 prose_73 prose_74 prose_75 prose_76 prose_77}

header_72 [label="3 : metas"]

prose_73 [label="prose"]

prose_74 [label="prose"]

prose_75 [label="prose"]

prose_76 [label="prose"]

prose_77 [label="prose"]


header_72 -> leaf_78
leaf_78  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** metas"]
prose_73 -> { raw_79}
{rank=same; raw_79}

raw_79 [label="raw"]


raw_79 -> leaf_80
leaf_80  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  By default a node will inherit from the Node class.  If you want custom behavior,
you must pass in a table of metatable constructors.
"]
prose_74 -> { raw_81 literal_82 raw_83 literal_84 raw_85 literal_86 raw_87 literal_88 raw_89 literal_90 raw_91 literal_92 raw_93}
{rank=same; raw_81 literal_82 raw_83 literal_84 raw_85 literal_86 raw_87 literal_88 raw_89 literal_90 raw_91 literal_92 raw_93}

raw_81 [label="raw"]

literal_82 [label="literal"]

raw_83 [label="raw"]

literal_84 [label="literal"]

raw_85 [label="raw"]

literal_86 [label="literal"]

raw_87 [label="raw"]

literal_88 [label="literal"]

raw_89 [label="raw"]

literal_90 [label="literal"]

raw_91 [label="raw"]

literal_92 [label="literal"]

raw_93 [label="raw"]


raw_81 -> leaf_94
leaf_94  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
That's a fairly specific beast.  Any rule defined above will have an "]
literal_82 -> leaf_95
leaf_95  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_83 -> leaf_96
leaf_96  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
corresonding to the name of the rule.  Unless "]
literal_84 -> leaf_97
leaf_97  [color=Gray,shape=rectangle,fontname=Inconsolata,label="SUPPRESS"]
raw_85 -> leaf_98
leaf_98  [color=Gray,shape=rectangle,fontname=Inconsolata,label="ed, this will become
a Node.  If the "]
literal_86 -> leaf_99
leaf_99  [color=Gray,shape=rectangle,fontname=Inconsolata,label="metas"]
raw_87 -> leaf_100
leaf_100  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" parameter has a key corresponding to "]
literal_88 -> leaf_101
leaf_101  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_89 -> leaf_102
leaf_102  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", then it
must return a function taking two parameters:
   
   - node :  The node under construction, which under normal circumstances will
             already have the "]
literal_90 -> leaf_103
leaf_103  [color=Gray,shape=rectangle,fontname=Inconsolata,label="first"]
raw_91 -> leaf_104
leaf_104  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and "]
literal_92 -> leaf_105
leaf_105  [color=Gray,shape=rectangle,fontname=Inconsolata,label="last"]
raw_93 -> leaf_106
leaf_106  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" fields.
   - str  :  The entire str the grammar is parsing.
"]
prose_75 -> { raw_107}
{rank=same; raw_107}

raw_107 [label="raw"]


raw_107 -> leaf_108
leaf_108  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which must return that same node, decorated in whatever fashion is appropriate.
"]
prose_76 -> { raw_109 literal_110 raw_111 literal_112 raw_113}
{rank=same; raw_109 literal_110 raw_111 literal_112 raw_113}

raw_109 [label="raw"]

literal_110 [label="literal"]

raw_111 [label="raw"]

literal_112 [label="literal"]

raw_113 [label="raw"]


raw_109 -> leaf_114
leaf_114  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The node will not have a metatable at this point, and the function must attach a
metatable with "]
literal_110 -> leaf_115
leaf_115  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
raw_111 -> leaf_116
leaf_116  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" equal to some table which itself has the "]
literal_112 -> leaf_117
leaf_117  [color=Gray,shape=rectangle,fontname=Inconsolata,label="__index"]
raw_113 -> leaf_118
leaf_118  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Node as some recursive backstop.
"]
prose_77 -> { raw_119 italic_120 raw_121}
{rank=same; raw_119 italic_120 raw_121}

raw_119 [label="raw"]

italic_120 [label="italic"]

raw_121 [label="raw"]


raw_119 -> leaf_122
leaf_122  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
You might say the return value must "]
italic_120 -> leaf_123
leaf_123  [color=Gray,shape=rectangle,fontname=Inconsolata,label="inherit"]
raw_121 -> leaf_124
leaf_124  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" from Node, if we were using
a language that did that sort of thing. 

"]
section_14 -> { header_125 prose_126 prose_127 prose_128 codeblock_129 prose_130 prose_131 codeblock_132}
{rank=same; header_125 prose_126 prose_127 prose_128 codeblock_129 prose_130 prose_131 codeblock_132}

header_125 [label="3 : includes"]

prose_126 [label="prose"]

prose_127 [label="prose"]

prose_128 [label="prose"]

codeblock_129 [label="code block 82-95"]

prose_130 [label="prose"]

prose_131 [label="prose"]

codeblock_132 [label="code block 101-116"]


header_125 -> leaf_133
leaf_133  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** includes"]
prose_126 -> { raw_134}
{rank=same; raw_134}

raw_134 [label="raw"]


raw_134 -> leaf_135
leaf_135  [color=Gray,shape=rectangle,fontname=Inconsolata,label="


- [ ] #todo  Note the require strings below, which prevent this from
             being a usable library. 
"]
prose_127 -> { raw_136 literal_137 raw_138 literal_139 raw_140}
{rank=same; raw_136 literal_137 raw_138 literal_139 raw_140}

raw_136 [label="raw"]

literal_137 [label="literal"]

raw_138 [label="raw"]

literal_139 [label="literal"]

raw_140 [label="raw"]


raw_136 -> leaf_141
leaf_141  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             The problem is almost a philosophical one, and it's what I'm
             setting out to solve with "]
literal_137 -> leaf_142
leaf_142  [color=Gray,shape=rectangle,fontname=Inconsolata,label="bridge"]
raw_138 -> leaf_143
leaf_143  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and "]
literal_139 -> leaf_144
leaf_144  [color=Gray,shape=rectangle,fontname=Inconsolata,label="manifest"]
raw_140 -> leaf_145
leaf_145  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_128 -> { raw_146 literal_147 raw_148}
{rank=same; raw_146 literal_147 raw_148}

raw_146 [label="raw"]

literal_147 [label="literal"]

raw_148 [label="raw"]


raw_146 -> leaf_149
leaf_149  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
             In the meantime, "]
literal_147 -> leaf_150
leaf_150  [color=Gray,shape=rectangle,fontname=Inconsolata,label="lpegnode"]
raw_148 -> leaf_151
leaf_151  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" has one consumer. Let's keep it
             happy. 
"]
codeblock_129 -> leaf_152
leaf_152  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local L = require \"lpeg\"

local s = require \"status\" ()
s.verbose = true
s.angry   = false

local a = require \"ansi\"

local Node = require \"node/node\"
local elpatt = require \"node/elpatt\"

local DROP = elpatt.DROP"]
prose_130 -> { raw_153}
{rank=same; raw_153}

raw_153 [label="raw"]


raw_153 -> leaf_154
leaf_154  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
I like the dedication shown in this style of import.
"]
prose_131 -> { raw_155}
{rank=same; raw_155}

raw_155 [label="raw"]


raw_155 -> leaf_156
leaf_156  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
It's the kind of thing I'd like to automate. 
"]
codeblock_132 -> leaf_157
leaf_157  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local assert = assert
local string, io = assert( string ), assert( io )
local V = string.sub( assert( _VERSION ), -4 )
local _G = assert( _G )
local error = assert( error )
local pairs = assert( pairs )
local next = assert( next )
local type = assert( type )
local tostring = assert( tostring )
local setmetatable = assert( setmetatable )
if V == \" 5.1\" then
   local setfenv = assert( setfenv )
   local getfenv = assert( getfenv )
end"]
section_15 -> { header_158 prose_159 codeblock_160 section_161 section_162}
{rank=same; header_158 prose_159 codeblock_160 section_161 section_162}

header_158 [label="3 : make_ast_node"]

prose_159 [label="prose"]

codeblock_160 [label="code block 124-126"]

section_161 [label="section: 129-159"]

section_162 [label="section: 160-365"]


header_158 -> leaf_163
leaf_163  [color=Gray,shape=rectangle,fontname=Inconsolata,label="*** make_ast_node"]
prose_159 -> { raw_164}
{rank=same; raw_164}

raw_164 [label="raw"]


raw_164 -> leaf_165
leaf_165  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  This takes a lot of parameters and does a lot of things. 

"]
codeblock_160 -> leaf_166
leaf_166  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function make_ast_node(id, first, t, last, str, metas, offset)"]
section_161 -> { header_167 prose_168 prose_169 codeblock_170}
{rank=same; header_167 prose_168 prose_169 codeblock_170}

header_167 [label="4 : setup values and metatables"]

prose_168 [label="prose"]

prose_169 [label="prose"]

codeblock_170 [label="code block 139-157"]


header_167 -> leaf_171
leaf_171  [color=Gray,shape=rectangle,fontname=Inconsolata,label="**** setup values and metatables"]
prose_168 -> { raw_172 link_173 raw_174}
{rank=same; raw_172 link_173 raw_174}

raw_172 [label="raw"]

link_173 [label="link"]

raw_174 [label="raw"]


raw_172 -> leaf_175
leaf_175  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  As "]
link_173 -> { anchortext_176 url_177}
{rank=same; anchortext_176 url_177}

anchortext_176 [label="anchortext"]

url_177 [label="url"]


anchortext_176 -> leaf_178
leaf_178  [color=Gray,shape=rectangle,fontname=Inconsolata,label="covered elsewhere"]
url_177 -> leaf_179
leaf_179  [color=Gray,shape=rectangle,fontname=Inconsolata,label="httk://"]
raw_174 -> leaf_180
leaf_180  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", we accept three varieties of
metatable verb.  An ordinary table is assigned; a table with __call is 
called, as is an ordinary function.
"]
prose_169 -> { raw_181 literal_182 raw_183 literal_184 raw_185 literal_186 raw_187}
{rank=same; raw_181 literal_182 raw_183 literal_184 raw_185 literal_186 raw_187}

raw_181 [label="raw"]

literal_182 [label="literal"]

raw_183 [label="raw"]

literal_184 [label="literal"]

raw_185 [label="raw"]

literal_186 [label="literal"]

raw_187 [label="raw"]


raw_181 -> leaf_188
leaf_188  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The latter two are expected to return the original table, now a descendent
of "]
literal_182 -> leaf_189
leaf_189  [color=Gray,shape=rectangle,fontname=Inconsolata,label="Node"]
raw_183 -> leaf_190
leaf_190  [color=Gray,shape=rectangle,fontname=Inconsolata,label=".  This need not have an "]
literal_184 -> leaf_191
leaf_191  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_185 -> leaf_192
leaf_192  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" field which is the same as the "]
literal_186 -> leaf_193
leaf_193  [color=Gray,shape=rectangle,fontname=Inconsolata,label="id"]
raw_187 -> leaf_194
leaf_194  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
parameter.
"]
codeblock_170 -> leaf_195
leaf_195  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   local offset = offset or 0
   t.first = first + offset
   t.last  = last + offset - 1
   t.str   = str
   if metas[id] then
      local meta = metas[id]
      if type(meta) == \"function\" or meta.__call then
        t = metas[id](t, str)
      else
        t = setmetatable(t, meta)
      end
      assert(t.id)
   else
      t.id = id
       setmetatable(t, {__index = Node,
                     __tostring = Node.toString})
   end"]
section_162 -> { header_196 prose_197 prose_198 prose_199 prose_200 prose_201 prose_202 prose_203 prose_204 prose_205 prose_206 prose_207 prose_208 codeblock_209 codeblock_210 codeblock_211 codeblock_212}
{rank=same; header_196 prose_197 prose_198 prose_199 prose_200 prose_201 prose_202 prose_203 prose_204 prose_205 prose_206 prose_207 prose_208 codeblock_209 codeblock_210 codeblock_211 codeblock_212}

header_196 [label="4 : DROP"]

prose_197 [label="prose"]

prose_198 [label="prose"]

prose_199 [label="prose"]

prose_200 [label="prose"]

prose_201 [label="prose"]

prose_202 [label="prose"]

prose_203 [label="prose"]

prose_204 [label="prose"]

prose_205 [label="prose"]

prose_206 [label="prose"]

prose_207 [label="prose"]

prose_208 [label="prose"]

codeblock_209 [label="code block 204-320"]

codeblock_210 [label="code block 322-341"]

codeblock_211 [label="code block 344-361"]

codeblock_212 [label="code block 363-365"]


header_196 -> leaf_213
leaf_213  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" DROP

  T"]
prose_197 -> { raw_214 literal_215 raw_216}
{rank=same; raw_214 literal_215 raw_216}

raw_214 [label="raw"]

literal_215 [label="literal"]

raw_216 [label="raw"]


raw_214 -> leaf_217
leaf_217  [color=Gray,shape=rectangle,fontname=Inconsolata,label="

  The rule "]
literal_215 -> leaf_218
leaf_218  [color=Gray,shape=rectangle,fontname=Inconsolata,label="elpatt.D"]
raw_216 -> leaf_219
leaf_219  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" causes the match to be dropped. In order for
this to give use the results we want, we must adjust the peer and
parent nodes while removing the captured element from the table. 
"]
prose_198 -> { raw_220 literal_221 raw_222}
{rank=same; raw_220 literal_221 raw_222}

raw_220 [label="raw"]

literal_221 [label="literal"]

raw_222 [label="raw"]


raw_220 -> leaf_223
leaf_223  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The use case is for eloquently expressed 'wrapper' patterns, which occur
frequently in real languages. In a "]
literal_221 -> leaf_224
leaf_224  [color=Gray,shape=rectangle,fontname=Inconsolata,label="(typical lisp expression)"]
raw_222 -> leaf_225
leaf_225  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" we don't need
the parentheses and would like our span not to include them.
"]
prose_199 -> { raw_226 literal_227 raw_228 literal_229 raw_230 literal_231 raw_232}
{rank=same; raw_226 literal_227 raw_228 literal_229 raw_230 literal_231 raw_232}

raw_226 [label="raw"]

literal_227 [label="literal"]

raw_228 [label="raw"]

literal_229 [label="literal"]

raw_230 [label="raw"]

literal_231 [label="literal"]

raw_232 [label="raw"]


raw_226 -> leaf_233
leaf_233  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
We could use a pattern like "]
literal_227 -> leaf_234
leaf_234  [color=Gray,shape=rectangle,fontname=Inconsolata,label="V\"formwrap\""]
raw_228 -> leaf_235
leaf_235  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" and then SUPPRESS "]
literal_229 -> leaf_236
leaf_236  [color=Gray,shape=rectangle,fontname=Inconsolata,label="formwrap"]
raw_230 -> leaf_237
leaf_237  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", but
this is less eloquent than "]
literal_231 -> leaf_238
leaf_238  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(P\"(\") * V\"form\" *  D(P\")\")"]
raw_232 -> leaf_239
leaf_239  [color=Gray,shape=rectangle,fontname=Inconsolata,label=". 
"]
prose_200 -> { raw_240 literal_241 raw_242}
{rank=same; raw_240 literal_241 raw_242}

raw_240 [label="raw"]

literal_241 [label="literal"]

raw_242 [label="raw"]


raw_240 -> leaf_243
leaf_243  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
Which is admittedly hard to look at.  We prefer the form"]
literal_241 -> leaf_244
leaf_244  [color=Gray,shape=rectangle,fontname=Inconsolata,label="D(pal) * V\"form\" * D(par)"]
raw_242 -> leaf_245
leaf_245  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" for this reason among others.
"]
prose_201 -> { raw_246 literal_247 raw_248}
{rank=same; raw_246 literal_247 raw_248}

raw_246 [label="raw"]

literal_247 [label="literal"]

raw_248 [label="raw"]


raw_246 -> leaf_249
leaf_249  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
The algorithm moves from the right to the left, because "]
literal_247 -> leaf_250
leaf_250  [color=Gray,shape=rectangle,fontname=Inconsolata,label="table.remove(t)"]
raw_248 -> leaf_251
leaf_251  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
is O(1) so we can strip any amount of rightward droppage first.  It is
correspondingly more expensive to strip middle drops, and most expensive
to strip leftmost drops.
"]
prose_202 -> { raw_252 literal_253 raw_254}
{rank=same; raw_252 literal_253 raw_254}

raw_252 [label="raw"]

literal_253 [label="literal"]

raw_254 [label="raw"]


raw_252 -> leaf_255
leaf_255  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
More importantly, if we counted up, we'd be tracking "]
literal_253 -> leaf_256
leaf_256  [color=Gray,shape=rectangle,fontname=Inconsolata,label="#t"]
raw_254 -> leaf_257
leaf_257  [color=Gray,shape=rectangle,fontname=Inconsolata,label=", a moving target.
Counting to 1 neatly prevents this.
"]
prose_203 -> { raw_258}
{rank=same; raw_258}

raw_258 [label="raw"]


raw_258 -> leaf_259
leaf_259  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
   -  [ ] #Todo :Faster:
"]
prose_204 -> { raw_260}
{rank=same; raw_260}

raw_260 [label="raw"]


raw_260 -> leaf_261
leaf_261  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  This algorithm, as we discussed, goes quadratic toward the left side.
        The correct way to go is if we see any drop, flip a dirty bit, and 
        compact upward.
"]
prose_205 -> { raw_262 literal_263 raw_264}
{rank=same; raw_262 literal_263 raw_264}

raw_262 [label="raw"]

literal_263 [label="literal"]

raw_264 [label="raw"]


raw_262 -> leaf_265
leaf_265  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
     -  More to the point, the mere inclusion of this much "]
literal_263 -> leaf_266
leaf_266  [color=Gray,shape=rectangle,fontname=Inconsolata,label="s:"]
raw_264 -> leaf_267
leaf_267  [color=Gray,shape=rectangle,fontname=Inconsolata,label=" slows the 
        algorithm to an utter crawl. The concatenations happen anyway, to
        pass the string into the status module.
"]
prose_206 -> { raw_268}
{rank=same; raw_268}

raw_268 [label="raw"]


raw_268 -> leaf_269
leaf_269  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        This is probably 10x the cost in real work.
"]
prose_207 -> { raw_270}
{rank=same; raw_270}

raw_270 [label="raw"]


raw_270 -> leaf_271
leaf_271  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        Why am I doing it in such a dumb way? This is a literate programming
        environment, and I'm building a language with templates and macros
        and other useful access to state at compile time.
"]
prose_208 -> { raw_272}
{rank=same; raw_272}

raw_272 [label="raw"]


raw_272 -> leaf_273
leaf_273  [color=Gray,shape=rectangle,fontname=Inconsolata,label="
        That's two ways to remove the verbosity and other printfs when they
        aren't wanted.  Better to simulate the correct behavior until I can
        provide it. 
"]
codeblock_209 -> leaf_274
leaf_274  [color=Gray,shape=rectangle,fontname=Inconsolata,label="   for i = #t, 1, -1 do 
      local cap = t[i] 
      if type(cap) ~= \"table\" then
         s:complain(\"CAPTURE ISSUE\", 
                    \"type of capture subgroup is \" .. type(v) .. \"\\n\")
      end
      if cap.DROP and getmetatable(cap) == DROP then
         s:verb(\"drops in \" .. a.bright(t.id))
         if i == #t then
            s:verb(a.red(\"rightmost\") .. \" remaining node\")
            s:verb(\"  t.$: \" .. tostring(t.last) .. \" Î”: \"
                   .. tostring(cap.last - cap.first))
            t.last = t.last - (cap.last - cap.first)
            table.remove(t)
            s:verb(\"  new t.$: \" .. tostring(t.last))
         else
            -- Here we may be either in the middle or at the leftmost
            -- margin.  Leftmost means either we're at index 1, or that
            -- all children to the left, down to 1, are all DROPs. 
            local leftmost = (i == 1)
            if leftmost then
               s:verb(a.cyan(\"  leftmost\") .. \" remaining node\")
               s:verb(\"    t.^: \" .. tostring(t.first)
                      .. \" D.$: \" .. tostring(cap.last))
               t.first = cap.last
               s:verb(\"    new t.^: \" .. tostring(t.first))
               table.remove(t, 1)
            else
               leftmost = true -- provisionally since cap.DROP
               for j = i, 1, -1 do
                 leftmost = leftmost and t[j].DROP 
                                     and getmetatable(t[j]) == DROP
                 if not leftmost then break end
               end
               if leftmost then
                  s:verb(a.cyan(\"  leftmost inner\") .. \" remaining node\")
                  s:verb(\"    t.^: \" .. tostring(t.first)
                         .. \" D.$: \" .. tostring(cap.last))
                  t.first = cap.last
                  s:verb(\"    new t.^: \" .. tostring(t.first))
                  for j = i, 1, -1 do
                     -- this is quadradic but correct 
                     -- and easy to understand.
                     table.remove(t, j)
                     break
                  end
               else
                  s:verb(a.green(\"  middle\") .. \" node dropped\")
                  table.remove(t, i)
               end
            end
         end
      end 
   end
   assert(t.isNode, \"failed isNode: \" .. id)
   assert(t.str)
   return t
end


-- some useful/common lpeg patterns
local Cp = L.Cp
local Cc = L.Cc
local Ct = L.Ct
local arg1_str = L.Carg(1)
local arg2_metas = L.Carg(2)
local arg3_offset = L.Carg(3)


-- setup an environment where you can easily define lpeg grammars
-- with lots of syntax sugar
local function define(func, g, e)
  g = g or {}
  if e == nil then
    e = V == \" 5.1\" and getfenv(func) or _G
  end
  local suppressed = {}
  local env = {}
  local env_index = {
    START = function(name) g[1] = name end,
    SUPPRESS = function(...)
      suppressed = {}
      for i = 1, select('#', ...) do
        suppressed[select(i, ... )] = true
      end
    end,
    V = L.V,
    P = L.P,
  }

  setmetatable(env_index, { __index = e })
  setmetatable(env, {
    __index = env_index,
    __newindex = function( _, name, val )
      if suppressed[ name ] then
        g[ name ] = val
      else
        g[ name ] = (Cc(name) 
              * Cp() 
              * Ct(val)
              * Cp()
              * arg1_str
              * arg2_metas)
              * arg3_offset / make_ast_node
      end
    end
  })
  -- call passed function with custom environment (5.1- and 5.2-style)
  if V == \" 5.1\" then
    setfenv( func, env )
  end
  func( env )
  assert( g[ 1 ] and g[ g[ 1 ] ], \"no start rule defined\" )
  return g
end"]
codeblock_210 -> leaf_275
leaf_275  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function refineMetas(metas)
  s:verb(\"refining metatables\")
  for id, meta in pairs(metas) do
    s:verb(\"  id: \" .. id .. \" type: \" .. type(meta))
    if type(meta) == \"table\" then
      if not meta[\"__tostring\"] then
        meta[\"__tostring\"] = Node.toString
      end
      if not meta.id then
        s:verb(\"    inserting metatable id: \" .. id)
        meta.id = id
      else
        s:verb(\"    id of \" .. id .. \" is \" .. meta.id)
      end
    end
  end
  return metas
end"]
codeblock_211 -> leaf_276
leaf_276  [color=Gray,shape=rectangle,fontname=Inconsolata,label="local function new(grammar_template, metas)
  if type(grammar_template) == 'function' then
    local metas = metas or {}
    metas = refineMetas(metas)
    local grammar = define(grammar_template, nil, metas)

    local function parse(str, offset)
      local offset = offset or 0
      return L.match(grammar, str, 1, str, metas, offset) -- other 
    end

    return parse
  else
    s:halt(\"no way to build grammar out of \" .. type(template))
  end
end"]
codeblock_212 -> leaf_277
leaf_277  [color=Gray,shape=rectangle,fontname=Inconsolata,label="return new"]

}
