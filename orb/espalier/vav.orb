* Vav


  Vav is an unbound collection of PEG rules, which may constitute a proper
Grammar.


** Rationale

  The various operations and rearrangements which I propose to perform on
PEGs is unrelated, in terms of implementation, to the use of that PEG through
binding it to some engine.

This is largely a matter of breaking the existing architecture down into its
constituent parts.


**** imports

#!lua
local core, cluster = use("qor:core", "cluster:cluster")

local pegpeg = use "espalier:peg/pegpeg"
local Metis = use "espalier:peg/metis"
#/lua

The inevitable metacircularity is delayed by using the existing peg/grammar
system for the rules themselves.

#!lua
local VavPeg = use "espalier:peg" (pegpeg, Metis) . parse
#/lua

The same with our Grammar module, which is a precomposed Qoph in the latest
fashion.

#!lua
local Grammar = use "espalier:espalier/grammar"
#/lua

We're juuuust about to swallow our own tails here.


** Vav

#!lua
local new, Vav, Vav_M = cluster.order()

Vav.pegparse = VavPeg


cluster.construct(new,
   function(_new, vav, peh)
     vav.grammar = VavPeg(peh)
     if vav.grammar then
        vav.grammar :hoist()
        vav.synth = vav.grammar :synthesize()
     else
        vav.failedParse = true
     end
     vav.peh = peh
     -- we'll have checks here

      return vav
   end)
#/lua


** Vav interface #Unstable

The need for an intermediate Node to generate the synth nodes from will not
be indefinite.

Vav will be the container for all the components, however.


*** Vav:constrain()

A pass-through which we'll be using for awhile at least.

#!lua
function Vav.constrain(vav)
   return vav.synth:constrain()
end
#/lua


*** Vav:dji()

For today's purposes, produces and attaches a grammar.

#!lua
function Vav.dji(vav)
   if not vav.lpeg_engine then
      vav.lpeg_engine = vav.synth :toLpeg() :string()
   end
   -- we need more than this, notably the metis, but.
   vav.parse, vav.pattern = Grammar(vav.lpeg_engine)
   return vav.parse
end
#/lua


*** Vav:try(rule?)

Generates a (hopefully) usable parser, even in the absence of the full
panoply of rules.

If the string =rule= is supplied, Vav will return a grammar for that rule.

#!lua
function Vav.try(vav, rule)
   local synth = vav.synth
   if not synth.calls then
      synth:analyze()
   end

   local anomalous = synth:anomalies()
   if anomalous and anomalous.missing then
      synth:makeDummies()
   elseif not rule then
      return vav:dji()
   end
   if rule then
      local peh = synth:pehFor(rule)
      local ruleVav = new(peh)
      return ruleVav :try(), ruleVav
   end

   vav.dummy = new(vav.peh .. vav.synth.dummy_rules)
   vav.test_engine = vav.dummy.synth :toLpeg() :string()
   vav.test_parse, vav.test_pattern = Grammar(vav.test_engine)
   return vav.test_parse
end
#/lua

#!lua
return new
#/lua

