* Vav


  Vav is an unbound collection of PEG rules, which may constitute a proper
Grammar.


*** This is actually the Peh and Vav combinator

Here's how it's supposed to work:

(deep breath)

Peh takes Gimel (grammar) returning Peh, Vav takes Peh Mem Tav (Mem Tav is a
combinator, name later) returning Vav, Dji takes Vav Qoph, returning Dji.

Gimel is a *syntactically* valid set of rules.  Peh provides the framework for
algebras on these rules.  This is currently the separation between analysis
and constraint in Metis: analysis is Peh, constraint is part of Vav.

Mem and Tav must pass a gate as well (dalet?), because Tav could refer to
parts which Mem doesn't recognize.

=Peh(gimel) :Dalet(mem, tav) :Dji(qoph) -> dji=?


** Rationale

  The various operations and rearrangements which I propose to perform on
PEGs is unrelated, in terms of implementation, to the use of that PEG through
binding it to some engine.

This is largely a matter of breaking the existing architecture down into its
constituent parts.


**** imports

#!lua
local core, cluster = use("qor:core", "cluster:cluster")

local pegpeg = use "espalier:peg/pegpeg"
local Metis = use "espalier:peg/metis"
#/lua

The inevitable metacircularity is delayed by using the existing peg/grammar
system for the rules themselves.

#!lua
local VavPeg = use "espalier:peg" (pegpeg, Metis)
local Vpeg = VavPeg.parse
#/lua

The same with our Grammar module, which is a precomposed Qoph in the latest
fashion.

#!lua
local Grammar = use "espalier:espalier/grammar"
#/lua

We're juuuust about to swallow our own tails here.


*** Vav combinator: Vav Peh Mem Tav

Vav is the entire front, resolving everything which is proper to the grammar.

Peh is the structural specification, Mem provides (specific) match-time
behaviors, and Tav is properties and behaviors which are common across match
classes. Tav can present both qualia, a map of a property to all the class
names which will carry it, and traits, specific metadata
(methods, canonically) for every metatable carrying the property.

The Vav combinator parses Peh, for rule analysis, and reconciles Mem and Tav
against the present rules.


** Vav

#!lua
local new, Vav, Vav_M = cluster.order()

Vav.pegparse = VavPeg

local _reconcile;

cluster.construct(new,
   function(_new, vav, peh, mem, tav)
      vav.peh = peh
      vav.grammar = VavPeg(peh)
      if vav.grammar then
         vav.grammar :hoist()
         vav.synth = vav.grammar :synthesize()
         -- signature is slightly odd here b/c :analyze returns anomalies
         -- so a nil means that all is well
         if (not vav.synth:analyze()) then
            if (mem or tav)  then
               _reconcile(vav, mem, tav)
            end
         end
      else
         vav.failedParse = true
      end
      -- we'll have checks here

      return vav
   end)
#/lua


**** _reconcile(vav, mem, tav?)

  Confirms that all keys of =mem=, and elements of the sets in =tav=, are
valid
matches for the grammar.

We confirm these invariants:

  -  Any key in =mem= must be a rule name /or/ a trait (key in tav)
  -  Any field in tav sets must be a rule name
  -  Keys in tav must *not* be rule names


Initially, any violation throws an error.  By design, Vav throws errors when
asked to do the impossible, which this isn't.  Eventually, we'll collect the
errors, if any, and return one of =vav= or =nil, errors=.

#!lua
function _reconcile(vav, mem, tav)
   tav = tav or {}
   local ruleMap = assert(vav.synth.ruleMap)
   local traits = {}
   for name, meta in pairs(mem) do
      if not ruleMap[name] then
         -- rethink all of this with clades!
         error("Grammar has no '" .. name .. "' rule.")
      end
   end
   -- extend the clade for remaining rules
   local _;
   for name in pairs(ruleMap) do
      -- statement-oriented languages amirites
      _ = mem[name]
   end
   -- decorate with tavs
   for trait, members in pairs(tav) do
      for elem in pairs(members) do
         if not ruleMap[elem] then
            error("Trait '" .. trait
                  .. "' has unknown member '" .. elem .. "'.")
         end
         mem[elem].trait = true
      end
   end
end
#/lua



** Vav interface #Unstable

The need for an intermediate Node to generate the synth nodes from will not
be indefinite.

Vav will be the container for all the components, however.


*** Pass-throughs


**** Vav:constrain()

A pass-through which we'll be using for awhile at least.

#!lua
function Vav.constrain(vav)
   return vav.synth:constrain()
end
#/lua


**** Vav:anomalies()

#!lua
function Vav.anomalies(vav)
   return vav.synth:anomalies()
end
#/lua


*** Vav:dji()

For today's purposes, produces and attaches a grammar.

#!lua
function Vav.dji(vav)
   if not vav.lpeg_engine then
      vav.lpeg_engine = vav.synth :toLpeg() :string()
   end
   -- we need more than this, notably the metis, but.
   vav.parse, vav.pattern = Grammar(vav.lpeg_engine)
   return vav.parse
end
#/lua


*** Vav:dji2()




*** Vav:try(rule?)

Generates a (hopefully) usable parser, even in the absence of the full
panoply of rules.

If the string =rule= is supplied, Vav will return a grammar for that rule.

#!lua
function Vav.try(vav, rule)
   local synth = vav.synth
   if not synth.calls then
      synth:analyze()
   end

   local anomalous = synth:anomalies()
   if anomalous and anomalous.missing then
      synth:makeDummies()
   elseif not rule then
      return vav:dji()
   end
   if rule then
      local peh = synth:pehFor(rule)
      local ruleVav = new(peh)
      return ruleVav :try(), ruleVav
   end
   vav.peh_dummy = vav.peh .. vav.synth.dummy_rules
   vav.dummy = new(vav.peh_dummy)
   vav.test_engine = vav.dummy.synth :toLpeg() :string()
   vav.test_parse, vav.test_pattern = Grammar(vav.test_engine)
   return vav.test_parse
end
#/lua

#!lua
return new
#/lua

