* Node


In the last couple of projects using Espalier, I've made 'synthetic nodes',
but there is no reason to have the original nodes other than expedience:
the Qoph combinator can generate whatever we need on capture.

This is therefore a rewrite of Node to present a better interface for
modifying the resulting tree, conforming to the new interface.


**** Main change

  We still receive =first, last, str, offset=, as well as the table we make
into the Node.  But we don't retain any of them but =.str=.

Instead we have =o, stride=: =o= is the first character of the string,
=stride= is one less than the length, which is the more convenient value in
Lua.  We also provide a full zipper during capture, with every child pointing
to the parent(as in Node), but also decorated with the index to the parent at
which the child is found, on the =up= field.

We do =stride= the Lua way, meaning it can be =-1= for a match with no width,
and so on.  Therefore =#span= for the the substring spanned by the node, which
we reach with =node:len()=, is simply =stride + 1=, and the last character is
=node.O + stride= globally, or =node.o + stride= locally.

This means we must use methods to insert and remove children, so that the
zipper remains valid.  It comes with many compensating advantages, notably
that walks can be accomplished statelessly by passing a node to an iteration
function which knows how to get to the next node.

There's a lot of room for caching and optimization here, but we need the
core working correctly as usual, so I describe the system with no memory or
intermediate cut points.

To take a span, the node finds the parent, which knows if the string has
changed and can adjust children accordingly. When this happens, we walk back
down the zipper, adjusting the offset, and return the string, which can then
be subspanned against the stride.  This can (should) be cached, since it
will only change if something under the node changes.

We can accomplish mutation in this fashion, without having to update anything
which hasn't changed in the process.  Adding, say, a statement to a Lua
block, will percolate up to the containing nodes, such as the function and
the Lua block recognizing the entire program, but won't affect other blocks
or statements in the function, nor any statements outside the function's
scope, until those nodes are accessed in a way which demands they update
references.

A simple technique to stay in sync is for each Node to be provided with a
version number =.v=, and a closure which returns the root version number.

This lets the child node look up the tree for the corresponding version, and
return to the child node updating all intermediates with that version and
the stride adjustment called for.


** Design

Once more with feeling!

The goal is that the string be /local/ to the Node, and /relative/ to a global
string which may or may not be the same string.

We need to be able to stitch together patches on strings, and delay allocating
and interning a new string indefinitely.  I've written a second Palimpsest
which is designed to work with the new Nodes.

The intention is that any Nodes which don't cross fragment boundaries are
backed by the Palimpsest, while Nodes which don't are left alone insofar as
possible.  So a node with a span of 4 to 8 on the original string might be at
10 to 14 on the Palimpsest, and 1 to 4 on the fragment, but it would still
have =.str= as the original string, and =.o= and =.stride= both =4=.

It's of course fine for any of the possible representations to be in play.
Specifically, we can replace any =.str= and a corresponding =.o=, as long as
the span is identical (not just the stride), without having to bump a version.
This lets us heal and break the model string at our convenience.

So every node has two instance slots, =.o= and =.O=, for the offset into
=.str= and the offset into the 'real string'.  It also has =.v=, which starts
at 1, this is passed to the root (a couple approaches here) and the version
adjusted for any node along the path.  This can be a recursive call up and
down, and probably should be.  The last Node might inform siblings, as a treat,
this is probably an optimization but that's unclear.

The parents, and only the parents, have to keep track of 'cracks', we handle
this with some heuristics about rule type and length such that a new string
is made for every change within something like a function.

Any node crossing these boundaries is backed by the Palimpsest.  It needs to
know which patches to apply to get the string understood in common by all
children, where ===o == O=== for all nodes =o=.  There is only one Palimpsest
per Node, so we can stash it if a Node is sectioned into a single string,
and go looking for any table-typed =.str= in the parental context if we don't
find it.

Version numbers track 1 to 1 with the creation of new strings (ignoring
interning since it's not relevant here), making undo relatively
straightforward to provide.

We'll extend this order for the case of intensive editing, such as a text
editor will need, for all urgent uses this scheme will be more than
sufficient.  Figuring out when a token is 'done' needs a concept of cursor
position, which the basal Node won't have.

Making a note that rendering a Node of this type can be a different operation
from converting it to a string, given that we pass in a writer, especially
one which can write some of a string without allocating.  More trouble than
it's worth now.

As an optimization, we can have a =v= of zero mean no changes are expected.
This can easily be made editable by updating every Node to 1, after which the
checks will be performed subsequently.  It will always be commonplace to have
Nodes which aren't mutated, and LuaJIT will remove this one-sided check from
traces.


**** The Parent Trap

  Having the parent/child relationship as bidirectional gives us a lot of
flexibility.

The issue is that the parent-child relationship is one-to-one.  We can
easily remove a Node, and grafting it is a matter of following to the root,
and applying the span as a patch.

If we want to copy though, we're stuck, because the kids can't point two
places, so we have to optimistically copy everything.

But what we could do, thanks to our fancy parsers, is store the span, and
Palimsest version, and make the 'child' a copy on /read/.  It can answer some
questions, but any =ipairs= or attempt to access the array summons the subspan
of the Pal version and parses it according to the rule, in-place.

That's pretty neat I think. The operation we do the most is practically free,
and the other one just happens when we need it.  Which we wouldn't often,
getting the entire subspan of the missing node, not to mention any parent,
wouldn't reallocate the kids.

This gets interesting since we can track the provenance of the graft in both
directions.


*** [#Todo] .l and .L

This is to keep track of the relative and absolute line.

This is really going to come in handy when we go deep on source mapping, which
is a necessary precondition for out-of-order Orb documents.


** Node

  Nodes are implemented using Cluster's Clade system, which is itself designed
to suit the peculiar needs of Nodes.

#!lua
local core = use "qor:core"
local table, string = core.table, core.string
local cluster, clade = use ("cluster:cluster", "cluster:clade")

local Pal = use "text:palimpsest2"
#/lua

Clades are built from a genre.  In this case we need our seeds to be
functions, which match the specific capture signature of Qoph, at least, our
default Qoph.


*** Node(first, t, last, str, offset)

=first= and =last= are the bounds of the capture, which is in =t=.  =str= is
the reference string, =offset= is positive when the parse begins anywhere but
the start of the string, otherwise =0=.

A given =t= will contain the child elements at the time of capture.

#Todo remove the self-pointer for parents, a nil =node.parent= is how we find
      root now.

#!lua
local function onmatch(first, t, last, str, offset)
   ---[[DBG]] assert(type(first) == 'number')
   ---[[DBG]] assert(type(t) == 'table')
   ---[[DBG]] assert(type(last) == 'number')
   ---[[DBG]] assert(type(str) == 'string')
   ---[[DBG]] assert(type(offset) == 'number')
   t.o = first + offset
   t.O = t.o
   t.stride = last - t.o - 1
   t.str = str
   for i, child in ipairs(t) do
      child.parent = t
      child.up = i
   end

   return t
end
#/lua

#!lua
local new, Node, Node_M = cluster.order { seed_fn = onmatch }
#/lua


**** Node.v

Nodes aren't editable by default, so we set =v= to =0=.

#!lua
Node.v = 1
#/lua


*** Node:adjust(v: i): skew: i, v_new: i

This we call first for almost anything, and contains the logic which brings a
node up to date.

Principle: a patch changes the =stride= of all parents, and the =.O= of
all later Nodes at every level.

We also bump the versions of everything, so every Node can go to the root, get
the latest version number, and look for the skew: the difference between .o
and .O for that Node.

Applying the skew repeatedly on the way down should get everything lined up.

Working it out:

- A fourth level is at v1, goes up to third, which is at v2, second is v3,
  first is also v3, zero skew (not uncommon), second has a skew of 1 (one
  byte insertion before it), third /had/ a skew of 3, gets bumped to 4, which
  is what the fourth level gets, all of them are v3 now.

#!lua
local function adjust(node, v)
   -- parent version should always be >= child after updates
   if node.v < v then
      error ("node ." .. node.tag .. " has .v " .. node.v .. "< " .. v)
   end
   if node:isRoot() then
      return node.O - node.o, node.v
   end

   local skew, v = adjust(node.parent, node.v)
   if v > node.v then
      node.O = node.O + skew
      node.v = v
   end

   return node.O - node.o, v
end
#/lua

#!lua
function Node.adjust(node)
   if node.v == 0 then return end
   adjust(node, node.v)
end
#/lua


** Metrics

Used to derive information from a given node.


*** Node:bounds()

#!lua
function Node.bounds(node)   node:adjust()
   return node.O, node.O + node.stride
end
#/lua


*** Node:span()

  This is one of our only opportunities to cross the boundaries of the
interned strings backing the logical string.

The Palimpsest will produce the substring, but not change the model in the
process.

#!lua
local sub = assert(string.sub)

function Node.span(node)   node:adjust()
   if string(node.str) then
      -- we're within a single string, small o
      return sub(node.str, node.o, node.o + node.stride)
   else
      -- palimpsest, big O
      return node.str:sub(node.O, node.O + node.stride)
   end
end
#/lua


*** Node:len()

Returns =#node:span()=.

No need to adjust, any node which changes stride passes the changes up to the
root.

#!lua
function Node.len(node)
   return node.stride + 1
end
#/lua


*** Node:depth()

Returns the number of parent nodes, which is =0= for the root.

#!lua
local function _deep(node, depth)
   if node:isRoot() then
      return depth
   else
      return _deep(node.parent, depth + 1)
   end
end

function Node.depth(node)
   return _deep(node, 0)
end
#/lua


*** Node:isRoot()

Replies =true= if the Node has no parent.

#!lua
function Node.isRoot(node)
   return not node.parent
end
#/lua


*** Node:linepos()

  Returns the line/row and column numbers of =node.O=, so this one gets fancy
with editing.

For =.v= of =0= it's simple enough.

#!lua
local linepos = assert(string.linepos)

function Node.linepos(node)
   if node.v == 0 then
      return linepos(node.str, node.o)
   end
end
#/lua


** Traversal

  The fully-linked structure lets us do our basic operations using stateless
iterators.

This is optimal, and that's essential, given that iterating AST nodes is
frequently the hottest loop in our programs.


*** Node:root()

  Returns the root of a given Node tree structure, which is the first parent
which does not, itself, have a parent.

#!lua
function Node.root(node)
   return not node.parent
          and node
           or node.parent:root()
end
#/lua


*** Node:forward(right_side: b?, short: Node?)

Returns the next (prefix, depth first) Node in the AST, or =nil= if it's the
last leaf.

=right_side= is a flag we set when we hit the right, =short= is a Node value
which we look for and return.  These are primarily intended for internal
use, =short= lets us finish an iteration where we started.

#!lua
function Node.forward(node, right_side, short)
   if short and rawequal(node, short) then
      return node
   end
   if right_side or (#node == 0) then
      if node:isRoot() then
         return nil
      end
      local sibling = node.parent[node.up + 1]
      if sibling then
         return sibling
      else
         -- right-most child returned
         return node.parent:forward(true, short)
      end
   end
   return node[1]
end
#/lua


*** Node:back(done: b?) #NYI

Returns the prior, postfix, depthfirst Node in the AST, or =nil= at the start.

We don't provide the short circuit, which is for subsearch.  If I see a use
case for reverse iterator, I'll come back to this decision.

#!lua
function Node:back(node, left_side)
   if node:isRoot() then return nil end

   if left_side then
      return node.parent
   end
   -- later...

end
#/lua


*** Node:walk()

  Produces a prefixed, depth-first search of the Node, starting with itself,
and containing only the children of that Node.

The Node returns itself first, because =:walk= is best suited to doing the
same thing to a bunch of nodes, which would lead to duplicated code preceding
for loops.

With =:forward=, we can write this as a stateless iterator.

#!lua
local function walk(base, latest)
   if not latest then
      return base
   else
      local short = nil
      if not rawequal(base, latest) then
         short = base
      end
      local next = latest:forward(false, short)
      if rawequal(base, next) then
         return nil
      else
         return next
      end
   end
end
#/lua

Which we simply return, when we want the iteraction in a for loop.

#!lua
function Node.walk(node)
   return walk, node
end
#/lua


**** Node:walker()

The only downside of this sort of iteration is that we can't make a value out
of it.

Whether this is necessary is an open question, but adding the affordance is
simple, and for filtering I can see a case for it.

#!lua
function Node.walker(node)
   local latest;
   return function()
      local next = walk(node, latest)
      if next then
         latest = next
         return next
      else
         return nil
      end
   end
end
#/lua


**** #NYI Breadth-First

I know this can be done statelessly, but it's tricky.

I used a breadth-first search once, and ended up regretting it.  It
infrequently resembles the shape of parse-structured data.

Worth adding, but not right now.


*** Selection

We'll be able to add an enriched palette here, but we start with the basics.


***** predicator(pred, node)

We allow predicates to be a string, which we compare with =.tag=.

Otherwise we call it (if we can), throwing an error for a bad predicate.

This follows the Bridge principle that a predicate should take the general,
then the specific, this is a higher-order predicate but the principle holds.

#!lua
local iscallable = assert(core.fn.iscallable)

local function predicator(pred, node)
   if type(pred) == 'string' then
      return node.tag == pred
   elseif iscallable(pred) then
      return not not pred(node)
   else
      error "invalid predicate"
   end
end
#/lua


**** Node:take(pred): Node?

Takes the first child node matching the predicate, if any.

Will not match itself, for obvious reasons.

#!lua
function Node.take(node, pred)
   for twig in walk, node do
      if predicator(pred, twig) then
         if twig ~= node then
            return twig
         end
      end
   end
   return nil
end
#/lua


**** Node:filter(pred)

=filter= needs to preserve some sort of state, and I'm not interested in
getting fancy about it, so this returns a closure for iteration.

Don't capture these as values, please.  I provide the synonym =filterer=,
which will continue to provide a closure in the event that I do get fancy
about it.

Fancy is making one curried closure per predicate, rather than one per
iteration.  This is worth trying, but only with a mature benchmarking system
to see whether LuaJIT actually cares.

#!lua
function Node.filter(node, pred)
   local latest = nil
   return function()
      for twig in walk, node, latest do
         if predicator(pred, twig) then
            latest = twig
            return twig
         end
      end
      return nil
   end
end
#/lua


**** Node:filterer(pred)

Currently a synonym, but this one is guaranteed to return a stateful iterator
which may be captured if desired.

#!lua
Node.filterer = Node.filter
#/lua


**** Node:search(pred) #Todo test

Search uses the predicate to look for matches in all nodes after the searcher.

This starts like =:filter= but escapes the containing node, searching the rest
of the tree.


#!lua
local function searcher(pred, node, latest)
   if not latest then
      latest = node
   end

   local further = latest:forward()
   if further == node then
      further = further:forward()
   end
   if further == nil then return end

   if predicator(pred, further) then
      return further
   end

   return searcher(pred, node, further)
end
#/lua

#!lua
local curry = core.fn.curry

function Node.search(node, pred)
   return curry(searcher, pred), node
end
#/lua


**** Node:searchback(pred) #NYI



** Edits

This is where we painstakingly make it all work.

Our invariant is that if the =.str= field is an actual string, then the local
=.o, .stride= tuple will give the span of the Node over that string.

This means that any Node which has a model span with more than one fragment
*must* have the Palimpsest as =.str=, but the opposite is not true: it's fine
for a Node to have a single span across a fragment, and still point to the
Palimpsest.

We don't create this situation for no reason, but if a Node goes solid, we
may or may not see to it that it points at a string.  If we're not removing or
moving the Node, it doesn't make a lot of sense.


***** .o and Palimpsests

Something to think about carefully: =.o= is probably meaningless for a Node
with a Palimpsest backing it.  Do we want to invalidate it?

One way to do this would be an =__index= function which returns =.O=, if
=.o= is =nil=.

The thing is, we use it to calculate skew: and skew remains very important
with Palimpsests, it's the difference between where the Node /thinks/ it is
and where it /actually/ is.

It basically doesn't matter how goofy that number gets as long as we can use
it to keep the bounds over the span.

We can legally set the two as equal for a leaf node, I think? Skew is skew,
it's only a problem to lose track of it if all the children haven't been
informed.

Alright, I believe I've talked myself out of it, =.o= is just the difference
between where the Node is, and where it 'thinks' it is.

What I do want to remember is that =.o= can be set equal to =.O= as long as:
the reference string is a Palimpsest, and all child nodes are on the same,
latest version.

It's not clear that this will be important.

What is important is retrieving and creating the Palimpsest!


**** thePalimpsest(node): Pal

Fetches the Palimsest, creating it if necessary.

Since any change under a Node means it needs to be backed by the Palimpsest,
we assign it to all parents on the way back down.

There being no need for a Palimpsest without intending mutation, we take the
opportunity to bump =.v= up to =1= if we have to.

Note that, as we do sometimes, we're assuming any table-valued =.str= will be,
not only a Palimpsest, but /the/ Palimpsest.

This is important because when we remove a Node, if it has a Palimpsest, we
need to reduce that to a string for all children which are also backed by a
Palimpsest.

As long as we preserve the invariant that no child will have any Palimpsest
unless the parent does, we can do this with a minimally-spanning,
breadth-first, recursive walk of the children.

#!lua
local function thePalimpsest(node)
   if type(node.str) == 'table' then
      return node.str
   end
   if node:isRoot() then
      node.str = Pal(node.str)
      -- bump to v1 if we have to
      if node.v == 0 then
         for twig in node :walk() do
            assert(twig.v == 0, "some node was already editable?")
            twig.v = 1
         end
      end
      return node.str
   end
   local pal = thePalimpsest(node.parent)
   node.str = pal

   return pal
end
#/lua


**** update(node, Δ)

Any patch requires us to call =update=.

This adjusts the stride of all parent nodes, and the =.O= of all posterior
siblings of the Node, and all parents with posterior siblings.

It also bumps the version, so that =adjust= will find changes.

#!lua
local function update(node, Δ)
   repeat
      local up = node.up
      node = node.parent
      node.v = node.v + 1
      node.stride = node.stride + Δ
      for i = up + 1, #node do
         local sib = node[i]
         sib.v = sib.v + 1
         sib.O = sib.O + Δ
      end
   until node:isRoot()
end
#/lua


*** Node:snip() :node

  This removes the Node from the parent, propagates the changes, sets up the
snipped Node to be a root, and returns it.

Actually, we should probably put a signal flag on the Node that says it's
not ready to be a full-on Node yet.

This is where shared structure can bite us if we're not careful, and help us
if we are.



**** removeNode(node)

This performs the removal and parental healing, while doing nothing for the
removed Node other than setting it up to be used as a graft.


#!lua
local function removeNode(node) -- :span will adjust for us
   local span = node:span()
   local pal = thePalimpsest(node)
   pal:patch("", node:bounds())
   update(node, -node:len())
   local top = #node.parent
   for i = node.up, top - 1 do
      node.parent[i] = node.parent[i + 1]
      node.parent[i].up = i
   end
   node.parent[top] = nil
   node.parent, node.up = nil, nil
   node.str = span
   node.o = 1
   node.unready = true
   return node
end

Node.snip = removeNode
#/lua


**** makeready(node, str, v, cut)

When we graft, we have a full span, so we can update all the kids to use it,
give them the right version, and set up =.o= and =.O= to track, respectively,
the reference and model strings.

#!lua
local function makeready(node, str, v, cut, skew)
   node.v = v
   node.str = str
   if node.unready then
      node.unready = nil
      skew = node.O
   else
      node.o = node.o + 0 -- hah
      node.O = node.O + skew
   end
   assert(type(skew) == 'number')
   for _, child in ipairs(node) do
      makeready(child, str, v, offset, skew)
   end
end
#/lua


*** Node:graft(child, i)

Attaches the child node as parent at index =i=, which must be provided.

As for any insertion, there is no return value.

#!lua
local floor = math.floor

function Node.graft(node, child, i)
   assert(type(i) == 'number' and i > 0 and floor(i) == i,
          "i must be a positive integer")
   if i > #node + 1 then
      error("Node has " .. #node .. " children, can't insert at " .. i)
   end
   local _, cut;
   if node[i] then
      _, cut = node[i]:bounds()
      cut = cut - 1
   else
      _, cut = node[#node]:bounds()
   end
   local span = child:span()

   local pal = thePalimpsest(node)
   pal:patch(span, cut)
   update(node, #span)
   if child.unready then
      makeready(child, span, node.v, cut)
   end
   local top = #node
   local this = child
   for j = i, top + 1 do
      this.up = j
      local sib = node[j]
      node[j] = this
      this = sib
   end
end
#/lua


*** Node :prepend(parent) :append(parent) :graft(parent, i)




*** Node:hoist()

Replaces the node with its only child in the parent tree.

Returns =true= if successful, otherwise reporting why it failed.

#!lua
function Node.hoist(node)
   if node:isRoot() then
      return nil, "can't hoist root node"
   end
   if #node ~= 1 then
      return nil, "can only hoist a node with one child"
   end
   node.parent[node.up] = node[1]
   return true
end
#/lua


*** Node:width() #Todo

Returns the printing width of the node.

Really? It returns what =utf8.width= returns.  This is adequate to many
purposes, but by no means all.

Annoyingly, we can't pass indexes to =width=, so to get a substring width
involves a lot of manual labor if we aren't to make a bunch of strings just
to put them on the tape measure.

#!lua
local utf8 = require "lua-utf8"
local width = assert(utf8.width)

function Node.width(node) node:adjust()
   local wid = 0
   local first, last, str = node.o, node.o

end
#/lua


**** __repr

We're going to base the next generation of repr technology on this, but first,
a simple lens.

#!lua
local Lens = use "repr:lens"
local Set = core.set

local suppress, show = Set {
   'parent',
   --'up'
}, Set {
   'tag'
}
local lens = { hide_key = suppress,
               show_key = show,
               depth = math.huge }
Node_M.__repr = Lens(lens)
#/lua



#!lua
return new
#/lua
