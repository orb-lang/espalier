* Node

In the last couple of projects using Espalier, I've made 'synthetic nodes',
but there is no reason to have the original nodes other than expedience:
the Qoph combinator can generate whatever we need on capture.

This is therefore a rewrite of Node to present a better interface for
modifying the resulting tree, conforming to the new interface.


**** Main change

The =first, last, str= triple is gone.

Instead we have =o, stride=, with no direct reference to the string.  We also
provide a full zipper during capture, with every child pointing to the parent
(as in Node), but also decorated with the index to the parent at which the
child is found, on the =up= field.

We do =stride= the Lua way, meaning it can be =-1= for a match with no width,
and so on.  Therefore =#span= for the the substring spanned by the node, which
we reach with =node:len()=, is simply =stride + 1=, and the last character is
=node.O + stride= globally, or =node.o + stride= locally.

This means we must use methods to insert and remove children, so that the
zipper remains valid.  It comes with many compensating advantages, notably
that walks can be accomplished statelessly by passing a node to an iteration
function which knows how to get to the next node.

There's a lot of room for caching and optimization here, but we need the
core working correctly as usual, so I describe the system with no memory or
intermediate cut points.

To take a span, the node finds the parent, which knows if the string has
changed and can adjust children accordingly. When this happens, we walk back
down the zipper, adjusting the offset, and return the string, which can then
be subspanned against the stride.  This can (should) be cached, since it
will only change if something under the node changes.

We can accomplish mutation in this fashion, without having to update anything
which hasn't changed in the process.  Adding, say, a statement to a Lua
block, will percolate up to the containing nodes, such as the function and
the Lua block recognizing the entire program, but won't affect other blocks
or statements in the function, nor any statements outside the function's
scope, until those nodes are accessed in a way which demands they update
references.

A simple technique to stay in sync is for each Node to be provided with a
version number =.v=, and a closure which returns the root version number.

This lets the child node look up the tree for the corresponding version, and
return to the child node updating all intermediates with that version and
the stride adjustment called for.


** Design

Once more with feeling!

The goal is that the string be /local/ to the Node, and /relative/ to a global
string which may or may not be the same string.

We need to be able to stitch together patches on strings, and delay allocating
and interning a new string indefinitely.  The Palimpsest, which we use
in 'Stache, is designed around this principle, the new Node should be more
'palimpsest native' if you will.

So every node has two instance slots, =.o= and =.O=, for the offset into
=.str= and the offset into the 'real string'.  It also has =.v=, which starts
at 1, this is passed to the root (a couple approaches here) and the version
adjusted for any node along the path.  This can be a recursive call up and
down, and probably should be.  The last Node might inform siblings, as a treat,
this is probably an optimization but that's unclear.

The parents, and only the parents, have to keep track of 'cracks', we handle
this with some heuristics about rule type and length such that a new string
is made for every change within something like a function.

Any node crossing these boundaries has what is in effect a Palimpsest, no
guarantees that exact module is suitable but it points the way.  It needs to
know which patches to apply to get the string understood in common by all
children, where ===o == O=== for all nodes =o=.

Version numbers track 1 to 1 with the creation of new strings (ignoring
interning since it's not relevant here), making undo relatively
straightforward to provide.

We'll extend this order for the case of intensive editing, such as a text
editor will need, for all urgent uses this scheme will be more than
sufficient.  Figuring out when a token is 'done' needs a concept of cursor
position, which the basal Node won't have.

Making a note that rendering a Node of this type can be a different operation
from converting it to a string, given that we pass in a writer, especially
one which can write some of a string without allocating.  More trouble than
it's worth now.

As an optimization, we can have a =v= of zero mean no changes are expected.
This can easily be made editable by updating every Node to 1, after which the
checks will be performed subsequently.  It will always be commonplace to have
Nodes which aren't mutated, and LuaJIT will remove this one-sided check from
traces.


*** [#Todo] .l and .L

This is to keep track of the relative and absolute line.

This is really going to come in handy when we go deep on source mapping, which
is a necessary precondition for out-of-order Orb documents.


** Node

  The Node is the base case of a cluster =clade=, which we have yet to
implement.

So we're going to build it one more time, and this time, we're doing it in
Cluster, where it belongs.

#!lua
local core = use "qor:core"
local cluster, clade = use ("cluster:cluster", "cluster:clade")
#/lua


Let's write a =new= and get going. Qoph needs some way to assign, after all.

This is a simplified signature in the interest of speed.


*** Node(first, t, last, str, offset)

#!lua
local function onmatch(first, t, last, str, offset)
   --[[DBG]] --[[
   assert(type(first) == 'number')
   assert(type(t) == 'table')
   assert(type(last) == 'number')
   assert(type(str) == 'string')
   assert(type(offset) == 'number')
   --[[DBG]]
   t.v = 0
   t.o = first + offset
   t.O = t.o
   t.stride = last - first + offset
   t.str = str
   if not t.parent then
      -- root is self, not null
      t.parent = t
      -- since t.parent[t.up] == t, we do this:
      t.up = 'parent'
   end
   -- we used to 'drop' invalid data which snuck in here,
   -- that should no longer be necessary
   for i, child in ipairs(t) do
      child.parent = t
      child.up = i
   end

   return t
end
#/lua

#!lua
local new, Node, Node_M = cluster.order { seed_fn = onmatch }
#/lua

We'll write a custom nodemaker for this and wire it to Vav, meanwhile, some
methods.


*** Node:adjust(): b

This we call first for almost anything, and contains the logic which brings a
node up to date.

#!lua
function Node.adjust(node)
   if node.v == 0 then
      return true
   end
end
#/lua


*** Node:span()

  This is one of our only opportunities to cross the boundaries of the
interned strings backing the logical string.

#!lua
local sub = assert(string.sub)

function Node.span(node)
   if node.v == 0 then
      -- means we don't have to use a method to look at the string
      return sub(node.str, node.o, node.o + node.stride)
   end
   -- the fun part
   node:adjust()
   if string(node.str) then
      -- we're within a single string, small o
      return sub(node.str, node.o, node.o + node.stride)
   else
      -- palimpsest, big O
      return node.str:sub(node.O, node.O + node.stride)
   end
end
#/lua


*** Node:bounds()

#!lua
function Node.bounds(node)  node:adjust()
   return node.O, node.O + node.stride
end
#/lua


*** Node:len()

Returns =#node:span()=.

No need to adjust, any node which changes stride passes the changes up to the
root.

#!lua
function Node.len(node)
   return node.stride + 1
end
#/lua


*** Node:forward()

Returns the next (prefix, depth first) Node in the AST, or =nil= if it's the
last leaf.

#!lua
function Node.forward(node, done)
   if done or (#node == 0) then
      if node.parent == node then
         return nil
      end
      local sibling = node.parent[node.up + 1]
      if sibling then
         return sibling
      else
         -- right-most child returned
         return node.parent:forward(true)
      end
   end
   return node[1]
end
#/lua


*** Node:walk()

With =:forward= a stateless iterator is easy.

#!lua
local function walk(base, last)
   if not last then
      return base
   else
      local next = last:forward()
      if rawequal(base, next) then
         return nil
      else
         return next
      end
   end
end
#/lua

#!lua
function Node.walk(node)
   return walk, node
end
#/lua

#!lua
local function predicator(node, pred)
   return type(pred) == 'string'
          and (twig.tag == pred)
          or pred(twig)
end
#/lua

#!lua
function Node.take(node, pred)
   for twig in walk, node do
      if predicator(twig, pred) then
         return twig
      end
   end
   return nil
end
#/lua


*** Node:hoist()

Replaces the node with its only child in the parent tree.

Returns =true= if successful, otherwise reporting why it failed.

#!lua
function Node.hoist(node)
   if node.parent == node then
      return nil, "can't hoist root node"
   end
   if #node ~= 1 then
      return nil, "can only hoist a node with one child"
   end
   node.parent[node.up] = node[1]
   return true
end
#/lua


*** Node:width() #Todo

Returns the printing width of the node.

Really? It returns what =utf8.width= returns.  This is adequate to many
purposes, but by no means all.

Annoyingly, we can't pass indexes to =width=, so to get a substring width
involves a lot of manual labor if we aren't to make a bunch of strings just
to put them on the tape measure.

#!lua
local utf8 = require "lua-utf8"
local width = assert(utf8.width)

function Node.width(node) node:adjust()
   local wid = 0
   local first, last, str = node.o, node.o

end
#/lua


**** __repr

We're going to base the next generation of repr technology on this, but first,
a simple lens.

#!lua
local Lens = use "repr:lens"
local Set = core.set

local suppress, show = Set {
   'parent',
   --'up'
}, Set {
   'tag'
}
local lens = { hide_key = suppress,
               show_key = show,
               depth = math.huge }
Node_M.__repr = Lens(lens)
#/lua




#!lua
return new
#/lua
